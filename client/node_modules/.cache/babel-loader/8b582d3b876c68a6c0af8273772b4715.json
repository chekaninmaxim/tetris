{"ast":null,"code":"import Settings from './settings.js';\nexport const makeInitialState = function () {\n  const blocksMap = [];\n\n  for (let i = 0; i < Settings.stageSize.height; i++) {\n    blocksMap.push(Array(10));\n  }\n\n  return {\n    movableBlocks: [{\n      position: {\n        x: 2,\n        y: 0\n      },\n      color: 'red'\n    }, {\n      position: {\n        x: 2,\n        y: 1\n      },\n      color: 'blue'\n    }, {\n      position: {\n        x: 3,\n        y: 1\n      },\n      color: 'yellow'\n    }, {\n      position: {\n        x: 2,\n        y: 2\n      },\n      color: 'red'\n    }],\n    blocksMap: blocksMap\n  };\n};\n\nfunction moveBlocksFactory(getNewPosition) {\n  const setStateFn = function (state) {\n    const isFigureStuck = state.movableBlocks.some(block => {\n      const newPosition = getNewPosition(block.position);\n      return Boolean(state.blocksMap[block.position.x][block.position.y + 1]) || newPosition.y >= Settings.stageSize.height - 1;\n    });\n\n    if (isFigureStuck) {\n      const newBlocksMap = state.blocksMap.slice();\n\n      for (let block of state.movableBlocks) {\n        newBlocksMap[block.position.x][block.position.y + 1] = block.color;\n      }\n\n      return {\n        movableBlocks: [],\n        blocksMap: newBlocksMap\n      };\n    } else {\n      const positionsEqual = function (p1, p2) {\n        p1.x === p2.x && p1.y === p2.y;\n      };\n\n      const blocksShoudNotMove = state.movableBlocks.some(b => positionsEqual(getNewPosition(b.position), b.position));\n\n      if (blocksShoudNotMove) {\n        return { ...state\n        };\n      } else {\n        const newMovableBlocks = state.movableBlocks.map(block => {\n          const newBlock = { ...block,\n            position: getNewPosition(block.position)\n          };\n          return newBlock;\n        });\n        return { ...state,\n          movableBlocks: newMovableBlocks\n        };\n      }\n    }\n  };\n\n  return setStateFn;\n}\n\nexport const moveBlocksDown = moveBlocksFactory(p => ({\n  x: p.x,\n  y: Math.min(p.y + 1, Settings.stageSize.height - 1)\n}));\nexport const moveBlocksLeft = moveBlocksFactory(p => ({\n  x: Math.max(p.x - 1, 0),\n  y: Math.min(p.y)\n}));\nexport const moveBlocksRight = moveBlocksFactory(p => ({\n  x: Math.min(p.x + 1, Settings.stageSize.width - 1),\n  y: Math.min(p.y)\n}));","map":{"version":3,"sources":["/home/ovo/projects/my-app/src/state.js"],"names":["Settings","makeInitialState","blocksMap","i","stageSize","height","push","Array","movableBlocks","position","x","y","color","moveBlocksFactory","getNewPosition","setStateFn","state","isFigureStuck","some","block","newPosition","Boolean","newBlocksMap","slice","positionsEqual","p1","p2","blocksShoudNotMove","b","newMovableBlocks","map","newBlock","moveBlocksDown","p","Math","min","moveBlocksLeft","max","moveBlocksRight","width"],"mappings":"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","sourcesContent":["import Settings from './settings.js';\n\nexport const makeInitialState = function() {\n\tconst blocksMap = [];\n\tfor (let i = 0; i < Settings.stageSize.height; i++) {\n\t\tblocksMap.push(Array(10));\n\t}\n\treturn {\n\t\tmovableBlocks : [\n\t\t\t{\n\t\t\t\tposition: {x: 2, y: 0},\n\t\t\t\tcolor: 'red'\n\t\t\t},\n\t\t\t{\n\t\t\t\tposition: {x: 2, y: 1},\n\t\t\t\tcolor: 'blue'\n\t\t\t},\n\t\t\t{\n\t\t\t\tposition: {x: 3, y: 1},\n\t\t\t\tcolor: 'yellow'\n\t\t\t},\n\t\t\t{\n\t\t\t\tposition: {x: 2, y: 2},\n\t\t\t\tcolor: 'red'\n\t\t\t},\n\t\t],\n\t\tblocksMap: blocksMap,\n\t}\n}\n\nfunction moveBlocksFactory(getNewPosition) {\n\tconst setStateFn = function(state) {\n\t\t\n\t\tconst isFigureStuck = state.movableBlocks.some(block => {\n\t\t\tconst newPosition = getNewPosition(block.position);\n\n\t\t\treturn Boolean(state.blocksMap[block.position.x][block.position.y + 1])\n\t\t\t\t|| newPosition.y >= Settings.stageSize.height -1;\n\t\t});\n\n\t\tif (isFigureStuck) {\n\t\t\tconst newBlocksMap = state.blocksMap.slice();\n\t\t\tfor (let block of state.movableBlocks) {\n\t\t\t\tnewBlocksMap[block.position.x][block.position.y + 1] = block.color;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tmovableBlocks : [],\n\t\t\t\tblocksMap: newBlocksMap\n\t\t\t}\n\t\t} else {\n\t\t\tconst positionsEqual = function(p1, p2) {\n\t\t\t\tp1.x === p2.x && p1.y === p2.y;\n\t\t\t}\n\n\t\t\tconst blocksShoudNotMove = state.movableBlocks.some(b =>\n\t\t\t\tpositionsEqual(getNewPosition(b.position), b.position)\n\t\t\t);\n\t\t\tif (blocksShoudNotMove) {\n\t\t\t\treturn {...state};\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tconst newMovableBlocks = state.movableBlocks.map(block => {\n\t\t\t\t\tconst newBlock = {\n\t\t\t\t\t\t...block,\n\t\t\t\t\t\tposition : getNewPosition(block.position)\n\t\t\t\t\t}\n\t\t\t\t\treturn newBlock;\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\tmovableBlocks: newMovableBlocks,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn setStateFn;\n}\n\nexport const moveBlocksDown = moveBlocksFactory(p => ({\n\tx: p.x,\n\ty: Math.min(p.y + 1, Settings.stageSize.height - 1)\n}));\n\nexport const moveBlocksLeft = moveBlocksFactory(p => ({\n\tx: Math.max(p.x - 1, 0),\n\ty: Math.min(p.y)\n}));\n\nexport const moveBlocksRight = moveBlocksFactory(p => ({\n\tx: Math.min(p.x + 1, Settings.stageSize.width - 1),\n\ty: Math.min(p.y)\n}));"]},"metadata":{},"sourceType":"module"}