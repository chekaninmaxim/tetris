{"ast":null,"code":"import Settings from './settings.js';\nimport getMovableBlock from './block.js';\nexport const makeInitialState = function () {\n  const blocksMap = [];\n\n  for (let i = 0; i < Settings.stageSize.height; i++) {\n    blocksMap.push(Array(Settings.stageSize.width));\n  }\n\n  return {\n    movableBlocks: getMovableBlock(),\n    blocksMap: blocksMap\n  };\n};\n\nfunction moveBlocksFactory(getNewPosition, isDown = false) {\n  const setStateFn = function (state) {\n    const isOverlapped = state.movableBlocks.some(block => {\n      const newPosition = getNewPosition(block.position);\n      return Boolean(state.blocksMap[newPosition.y][newPosition.x]);\n    });\n\n    if (isFigureStuck) {\n      const newBlocksMap = state.blocksMap.slice();\n\n      for (let block of state.movableBlocks) {\n        // const newPosition = getNewPosition(block.position);\n        console.log(block.position);\n        newBlocksMap[block.position.y][block.position.x] = block.color;\n      }\n\n      return {\n        movableBlocks: [],\n        blocksMap: newBlocksMap\n      };\n    } else {\n      const positionsEqual = function (p1, p2) {\n        return p1.x === p2.x && p1.y === p2.y;\n      };\n\n      const blocksShoudNotMove = state.movableBlocks.some(b => positionsEqual(getNewPosition(b.position), b.position));\n\n      if (blocksShoudNotMove) {\n        return state;\n      } else {\n        const newMovableBlocks = state.movableBlocks.map(block => {\n          const newBlock = { ...block,\n            position: getNewPosition(block.position)\n          };\n          return newBlock;\n        });\n        return { ...state,\n          movableBlocks: newMovableBlocks\n        };\n      }\n    }\n  };\n\n  return setStateFn;\n}\n\nexport const moveBlocksDown = moveBlocksFactory(p => ({\n  x: p.x,\n  y: Math.min(p.y + 1, Settings.stageSize.height - 1)\n}), true);\nexport const moveBlocksLeft = moveBlocksFactory(p => ({\n  x: Math.max(p.x - 1, 0),\n  y: p.y\n}));\nexport const moveBlocksRight = moveBlocksFactory(p => ({\n  x: Math.min(p.x + 1, Settings.stageSize.width - 1),\n  y: p.y\n}));","map":{"version":3,"sources":["/home/ovo/projects/my-app/src/state.js"],"names":["Settings","getMovableBlock","makeInitialState","blocksMap","i","stageSize","height","push","Array","width","movableBlocks","moveBlocksFactory","getNewPosition","isDown","setStateFn","state","isOverlapped","some","block","newPosition","position","Boolean","y","x","isFigureStuck","newBlocksMap","slice","console","log","color","positionsEqual","p1","p2","blocksShoudNotMove","b","newMovableBlocks","map","newBlock","moveBlocksDown","p","Math","min","moveBlocksLeft","max","moveBlocksRight"],"mappings":"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","sourcesContent":["import Settings from './settings.js';\nimport getMovableBlock from './block.js';\n\nexport const makeInitialState = function() {\n\tconst blocksMap = [];\n\n\tfor (let i = 0; i < Settings.stageSize.height; i++) {\n\t\tblocksMap.push(Array(Settings.stageSize.width));\n\t}\n\n\treturn {\n\t\tmovableBlocks : getMovableBlock(),\n\t\tblocksMap: blocksMap,\n\t}\n}\n\nfunction moveBlocksFactory(getNewPosition, isDown=false) {\n\tconst setStateFn = function(state) {\n\n\t\tconst isOverlapped = state.movableBlocks.some(block => {\n\t\t\tconst newPosition = getNewPosition(block.position);\n\n\t\t\treturn Boolean(state.blocksMap[newPosition.y][newPosition.x])\n\t\t});\n\n\t\tif (isFigureStuck) {\n\t\t\tconst newBlocksMap = state.blocksMap.slice();\n\t\t\tfor (let block of state.movableBlocks) {\n\t\t\t\t// const newPosition = getNewPosition(block.position);\n\t\t\t\tconsole.log(block.position);\n\t\t\t\tnewBlocksMap[block.position.y][block.position.x] = block.color;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tmovableBlocks : [],\n\t\t\t\tblocksMap: newBlocksMap\n\t\t\t}\n\t\t} else {\n\t\t\tconst positionsEqual = function(p1, p2) {\n\t\t\t\treturn p1.x === p2.x && p1.y === p2.y\n\t\t\t}\n\n\t\t\tconst blocksShoudNotMove = state.movableBlocks.some(b =>\n\t\t\t\tpositionsEqual(getNewPosition(b.position), b.position)\n\t\t\t);\n\t\t\tif (blocksShoudNotMove) {\n\t\t\t\treturn state;\n\t\t\t} else {\n\n\t\t\t\tconst newMovableBlocks = state.movableBlocks.map(block => {\n\t\t\t\t\tconst newBlock = {\n\t\t\t\t\t\t...block,\n\t\t\t\t\t\tposition : getNewPosition(block.position)\n\t\t\t\t\t}\n\t\t\t\t\treturn newBlock;\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\tmovableBlocks: newMovableBlocks,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn setStateFn;\n}\n\nexport const moveBlocksDown = moveBlocksFactory(p => ({\n\tx: p.x,\n\ty: Math.min(p.y + 1, Settings.stageSize.height - 1)\n}), true);\n\nexport const moveBlocksLeft = moveBlocksFactory(p => ({\n\tx: Math.max(p.x - 1, 0),\n\ty: p.y\n}));\n\nexport const moveBlocksRight = moveBlocksFactory(p => ({\n\tx: Math.min(p.x + 1, Settings.stageSize.width - 1),\n\ty: p.y\n}));\n"]},"metadata":{},"sourceType":"module"}