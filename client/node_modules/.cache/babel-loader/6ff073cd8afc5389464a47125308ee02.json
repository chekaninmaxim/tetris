{"ast":null,"code":"import Settings from './settings.js';\nexport const makeInitialState = function () {\n  const blocksMap = [];\n\n  for (let i = 0; i < Settings.stageSize.height; i++) {\n    blocksMap.push(Array(10));\n  }\n\n  return {\n    movableBlocks: [],\n    blocksMap: blocksMap\n  };\n};\nexport const movableBlocksDown = function (state) {\n  // for (let block of state.movableBlocks) {\n  // \tconst newX = block.position.x;\n  // \tconst newY = block.position.y + 1;\n  // \tif (state.blocksMap[newY][newX]) {\n  // \t\tconst newBlocksMap = state.blocksMap.slice();\n  // \t\treturn {}\n  // \t}\n  // }\n  isFigureStuck = state.movableBlocks.some(block => {\n    const newY = block.position.y + 1;\n    const newX = block.position.x;\n    const isOutOfBounds = 0 <= newX && newX < Settings.stageSize.width && 0 <= newY && newY < Settings.stageSize.height;\n    const isStuck = Boolean(state.blocksMap[block.position.x][block.position.y + 1]);\n    isOutOfBounds || isStuck;\n  });\n\n  if (isFigureStuck) {\n    const newBlocksMap = state.blocksMap.slice();\n\n    for (let block of state.movableBlocks) {\n      newBlocksMap[block.position.x][block.position.y + 1] = block.color;\n    }\n\n    return {\n      movableBlocks: [],\n      blocksMap: newBlocksMap\n    };\n  } else {\n    const newMovableBlocks = state.movableBlocks.map(block => {\n      const newBlock = { ...block,\n        position: {\n          x: block.position.x,\n          y: block.position.y\n        }\n      };\n      return newBlock;\n    });\n  }\n};","map":{"version":3,"sources":["/home/ovo/projects/my-app/src/state.js"],"names":["Settings","makeInitialState","blocksMap","i","stageSize","height","push","Array","movableBlocks","movableBlocksDown","state","isFigureStuck","some","block","newY","position","y","newX","x","isOutOfBounds","width","isStuck","Boolean","newBlocksMap","slice","color","newMovableBlocks","map","newBlock"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,eAArB;AAEA,OAAO,MAAMC,gBAAgB,GAAG,YAAW;AAC1C,QAAMC,SAAS,GAAG,EAAlB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAAQ,CAACI,SAAT,CAAmBC,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;AACnDD,IAAAA,SAAS,CAACI,IAAV,CAAeC,KAAK,CAAC,EAAD,CAApB;AACA;;AACD,SAAO;AACNC,IAAAA,aAAa,EAAG,EADV;AAENN,IAAAA,SAAS,EAAEA;AAFL,GAAP;AAIA,CATM;AAWP,OAAO,MAAMO,iBAAiB,GAAG,UAASC,KAAT,EAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,aAAa,GAAGD,KAAK,CAACF,aAAN,CAAoBI,IAApB,CAAyBC,KAAK,IAAI;AACjD,UAAMC,IAAI,GAAGD,KAAK,CAACE,QAAN,CAAeC,CAAf,GAAmB,CAAhC;AACA,UAAMC,IAAI,GAAGJ,KAAK,CAACE,QAAN,CAAeG,CAA5B;AAEA,UAAMC,aAAa,GAAG,KAAKF,IAAL,IAClBA,IAAI,GAAGjB,QAAQ,CAACI,SAAT,CAAmBgB,KADR,IAElB,KAAKN,IAFa,IAGlBA,IAAI,GAAGd,QAAQ,CAACI,SAAT,CAAmBC,MAH9B;AAKA,UAAMgB,OAAO,GAAGC,OAAO,CAACZ,KAAK,CAACR,SAAN,CAAgBW,KAAK,CAACE,QAAN,CAAeG,CAA/B,EAAkCL,KAAK,CAACE,QAAN,CAAeC,CAAf,GAAmB,CAArD,CAAD,CAAvB;AACAG,IAAAA,aAAa,IAAIE,OAAjB;AACA,GAXe,CAAhB;;AAaA,MAAIV,aAAJ,EAAmB;AAClB,UAAMY,YAAY,GAAGb,KAAK,CAACR,SAAN,CAAgBsB,KAAhB,EAArB;;AACA,SAAK,IAAIX,KAAT,IAAkBH,KAAK,CAACF,aAAxB,EAAuC;AACtCe,MAAAA,YAAY,CAACV,KAAK,CAACE,QAAN,CAAeG,CAAhB,CAAZ,CAA+BL,KAAK,CAACE,QAAN,CAAeC,CAAf,GAAmB,CAAlD,IAAuDH,KAAK,CAACY,KAA7D;AACA;;AACD,WAAO;AACNjB,MAAAA,aAAa,EAAG,EADV;AAENN,MAAAA,SAAS,EAAEqB;AAFL,KAAP;AAIA,GATD,MASO;AACN,UAAMG,gBAAgB,GAAGhB,KAAK,CAACF,aAAN,CAAoBmB,GAApB,CAAwBd,KAAK,IAAI;AACzD,YAAMe,QAAQ,GAAG,EAChB,GAAGf,KADa;AAEhBE,QAAAA,QAAQ,EAAG;AACVG,UAAAA,CAAC,EAAEL,KAAK,CAACE,QAAN,CAAeG,CADR;AAEVF,UAAAA,CAAC,EAAEH,KAAK,CAACE,QAAN,CAAeC;AAFR;AAFK,OAAjB;AAOA,aAAOY,QAAP;AACA,KATwB,CAAzB;AAUA;AACD,CA3CM","sourcesContent":["import Settings from './settings.js';\n\nexport const makeInitialState = function() {\n\tconst blocksMap = [];\n\tfor (let i = 0; i < Settings.stageSize.height; i++) {\n\t\tblocksMap.push(Array(10));\n\t}\n\treturn {\n\t\tmovableBlocks : [],\n\t\tblocksMap: blocksMap,\n\t}\n}\n\nexport const movableBlocksDown = function(state) {\n\t// for (let block of state.movableBlocks) {\n\t// \tconst newX = block.position.x;\n\t// \tconst newY = block.position.y + 1;\n\t// \tif (state.blocksMap[newY][newX]) {\n\t// \t\tconst newBlocksMap = state.blocksMap.slice();\n\t// \t\treturn {}\n\t// \t}\n\t// }\n\tisFigureStuck = state.movableBlocks.some(block => {\n\t\tconst newY = block.position.y + 1;\n\t\tconst newX = block.position.x;\n\n\t\tconst isOutOfBounds = 0 <= newX\n\t\t\t&& newX < Settings.stageSize.width\n\t\t\t&& 0 <= newY\n\t\t\t&& newY < Settings.stageSize.height;\n\n\t\tconst isStuck = Boolean(state.blocksMap[block.position.x][block.position.y + 1]);\n\t\tisOutOfBounds || isStuck;\n\t});\n\n\tif (isFigureStuck) {\n\t\tconst newBlocksMap = state.blocksMap.slice();\n\t\tfor (let block of state.movableBlocks) {\n\t\t\tnewBlocksMap[block.position.x][block.position.y + 1] = block.color;\n\t\t}\n\t\treturn {\n\t\t\tmovableBlocks : [],\n\t\t\tblocksMap: newBlocksMap\n\t\t}\n\t} else {\n\t\tconst newMovableBlocks = state.movableBlocks.map(block => {\n\t\t\tconst newBlock = {\n\t\t\t\t...block,\n\t\t\t\tposition : {\n\t\t\t\t\tx: block.position.x,\n\t\t\t\t\ty: block.position.y\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newBlock;\n\t\t})\n\t}\n}"]},"metadata":{},"sourceType":"module"}