{"ast":null,"code":"import Settings from './settings.js';\nimport getMovableBlock from './block.js';\nexport const makeInitialState = function () {\n  const blocksMap = [];\n\n  for (let i = 0; i < Settings.stageSize.height; i++) {\n    blocksMap.push(Array(Settings.stageSize.width));\n  }\n\n  return {\n    movableBlocks: getMovableBlock(),\n    blocksMap: blocksMap\n  };\n};\n\nconst positionsEqual = function (p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n};\n\nfunction moveBlocksFactory(getNewPosition, isDown = false) {\n  const setStateFn = function (state) {\n    const newPositions = state.movableBlocks.map(block => {\n      const newPosition = getNewPosition(block.position);\n\n      if (state.blocksMap[newPosition.y][newPosition.x]) {\n        return block.position;\n      } else {\n        return newPosition;\n      }\n    });\n    const isMoveInvalid = state.movableBlocks.some((block, i) => positionsEqual(block.position, newPositions[i]));\n\n    if (isMoveInvalid) {\n      if (isDown) {\n        const newBlocksMap = state.blocksMap.slice();\n\n        for (let block of state.movableBlocks) {\n          newBlocksMap[block.position.y][block.position.x] = block.color;\n        }\n\n        return {\n          movableBlocks: [],\n          blocksMap: newBlocksMap\n        };\n      } else {\n        return state;\n      }\n    } else {\n      const newMovableBlocks = state.movableBlocks.map((block, i) => {\n        const newBlock = { ...block,\n          position: newPositions[i]\n        };\n        return newBlock;\n      });\n      return { ...state,\n        movableBlocks: newMovableBlocks\n      };\n    }\n  };\n\n  return setStateFn;\n}\n\nexport const moveBlocksDown = moveBlocksFactory(p => ({\n  x: p.x,\n  y: Math.min(p.y + 1, Settings.stageSize.height - 1)\n}), true);\nexport const moveBlocksLeft = moveBlocksFactory(p => ({\n  x: Math.max(p.x - 1, 0),\n  y: p.y\n}));\nexport const moveBlocksRight = moveBlocksFactory(p => ({\n  x: Math.min(p.x + 1, Settings.stageSize.width - 1),\n  y: p.y\n}));","map":{"version":3,"sources":["/home/ovo/projects/my-app/src/state.js"],"names":["Settings","getMovableBlock","makeInitialState","blocksMap","i","stageSize","height","push","Array","width","movableBlocks","positionsEqual","p1","p2","x","y","moveBlocksFactory","getNewPosition","isDown","setStateFn","state","newPositions","map","block","newPosition","position","isMoveInvalid","some","newBlocksMap","slice","color","newMovableBlocks","newBlock","moveBlocksDown","p","Math","min","moveBlocksLeft","max","moveBlocksRight"],"mappings":"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","sourcesContent":["import Settings from './settings.js';\nimport getMovableBlock from './block.js';\n\nexport const makeInitialState = function() {\n\tconst blocksMap = [];\n\n\tfor (let i = 0; i < Settings.stageSize.height; i++) {\n\t\tblocksMap.push(Array(Settings.stageSize.width));\n\t}\n\n\treturn {\n\t\tmovableBlocks : getMovableBlock(),\n\t\tblocksMap: blocksMap,\n\t}\n}\n\nconst positionsEqual = function(p1, p2) {\n\treturn p1.x === p2.x && p1.y === p2.y\n}\n\n\nfunction moveBlocksFactory(getNewPosition, isDown=false) {\n\n\tconst setStateFn = function(state) {\n\n\t\tconst newPositions = state.movableBlocks.map(block => {\n\t\t\tconst newPosition = getNewPosition(block.position);\n\t\t\tif (state.blocksMap[newPosition.y][newPosition.x]) {\n\t\t\t\treturn block.position\n\t\t\t} else {\n\t\t\t\treturn newPosition\n\t\t\t}\n\t\t});\n\n\t\tconst isMoveInvalid = state.movableBlocks.some(\n\t\t\t(block, i) => positionsEqual(block.position, newPositions[i])\n\t\t);\n\n\t\tif (isMoveInvalid) {\n\t\t\tif (isDown) {\n\n\t\t\t\tconst newBlocksMap = state.blocksMap.slice();\n\t\t\t\tfor (let block of state.movableBlocks) {\n\t\t\t\t\tnewBlocksMap[block.position.y][block.position.x] = block.color;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tmovableBlocks : [],\n\t\t\t\t\tblocksMap: newBlocksMap\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t} else {\n\t\t\tconst newMovableBlocks = state.movableBlocks.map((block, i) => {\n\t\t\t\tconst newBlock = {\n\t\t\t\t\t...block,\n\t\t\t\t\tposition : newPositions[i]\n\t\t\t\t}\n\t\t\t\treturn newBlock;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tmovableBlocks: newMovableBlocks,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn setStateFn;\n}\n\nexport const moveBlocksDown = moveBlocksFactory(p => ({\n\tx: p.x,\n\ty: Math.min(p.y + 1, Settings.stageSize.height - 1)\n}), true);\n\nexport const moveBlocksLeft = moveBlocksFactory(p => ({\n\tx: Math.max(p.x - 1, 0),\n\ty: p.y\n}));\n\nexport const moveBlocksRight = moveBlocksFactory(p => ({\n\tx: Math.min(p.x + 1, Settings.stageSize.width - 1),\n\ty: p.y\n}));\n"]},"metadata":{},"sourceType":"module"}