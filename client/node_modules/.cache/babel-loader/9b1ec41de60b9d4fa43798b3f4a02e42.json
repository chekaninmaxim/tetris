{"ast":null,"code":"import Settings from './settings';\nimport C from './constants';\nimport { getMovableBlock, TetrisFigure } from './block';\nexport const makeInitialState = function () {\n  const blocksMap = [];\n\n  for (let i = 0; i < Settings.stageSize.height; i++) {\n    blocksMap.push(Array(Settings.stageSize.width));\n  }\n\n  return {\n    figure: getMovableBlock(),\n    blocksMap: blocksMap\n  };\n};\n\nconst positionsEqual = function ({\n  x1,\n  y1\n}, {\n  x2,\n  y2\n}) {\n  return x1 === x2 && y1 === y2;\n};\n\nexport function moveBlocksFactory(action) {\n  const setStateFn = function ({\n    figure,\n    blocksMap\n  }) {\n    if (action === C.ROTATE) console.log(action);\n    const oldPositions = figure.blocks;\n    const newFigure = getNextFigure(figure, action);\n    const newPositions = newFigure.blocks;\n    const isStuck = newPositions.some(block => blocksMap[block.y][block.x]);\n    const samePositions = newPositions.every((block, i) => positionsEqual(block, oldPositions[i]));\n\n    if (action == C.DOWN) {\n      if (isStuck || samePositions) {\n        const newBlocksMap = blocksMap.slice();\n\n        for (let block of oldPositions) {\n          newBlocksMap[block.y][block.x] = figure.color;\n        }\n\n        return {\n          figure: null,\n          blocksMap: newBlocksMap\n        };\n      } else {\n        return {\n          figure: newFigure,\n          blocksMap\n        };\n      }\n    } else {\n      return {\n        figure: isStuck ? figure : newFigure,\n        blocksMap\n      };\n    }\n  };\n\n  return setStateFn;\n}\n\nfunction getNextFigure(figure, action) {\n  const {\n    x,\n    y\n  } = figure.position;\n\n  switch (action) {\n    case C.LEFT:\n      return figure.move({\n        x: x - 1,\n        y\n      });\n\n    case C.RIGHT:\n      return figure.move({\n        x: x + 1,\n        y\n      });\n\n    case C.DOWN:\n      return figure.move({\n        x,\n        y: y + 1\n      });\n\n    case C.ROTATE:\n      return figure.rotate();\n\n    default:\n      return figure;\n  }\n}","map":{"version":3,"sources":["/home/ovo/projects/my-app/src/state.js"],"names":["Settings","C","getMovableBlock","TetrisFigure","makeInitialState","blocksMap","i","stageSize","height","push","Array","width","figure","positionsEqual","x1","y1","x2","y2","moveBlocksFactory","action","setStateFn","ROTATE","console","log","oldPositions","blocks","newFigure","getNextFigure","newPositions","isStuck","some","block","y","x","samePositions","every","DOWN","newBlocksMap","slice","color","position","LEFT","move","RIGHT","rotate"],"mappings":"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","sourcesContent":["import Settings from './settings'\nimport C from './constants'\nimport { getMovableBlock, TetrisFigure } from './block'\n\nexport const makeInitialState = function() {\n\tconst blocksMap = [];\n\n\tfor (let i = 0; i < Settings.stageSize.height; i++) {\n\t\tblocksMap.push(Array(Settings.stageSize.width));\n\t}\n\n\treturn {\n\t\tfigure : getMovableBlock(),\n\t\tblocksMap: blocksMap,\n\t}\n}\n\nconst positionsEqual = function({x1, y1}, {x2, y2}) {\n\treturn x1 === x2 && y1 === y2\n}\n\nexport function moveBlocksFactory(action) {\n\n\tconst setStateFn = function({figure, blocksMap}) {\n\n\t\tif (action === C.ROTATE) console.log(action);\n\t\tconst oldPositions = figure.blocks;\n\t\tconst newFigure = getNextFigure(figure, action)\n\t\tconst newPositions = newFigure.blocks;\n\n\t\tconst isStuck = newPositions.some(\n\t\t\tblock => blocksMap[block.y][block.x]\n\t\t);\n\n\t\tconst samePositions = newPositions.every(\n\t\t\t(block, i) => positionsEqual(block, oldPositions[i])\n\t\t);\n\t\t\n\t\tif (action == C.DOWN) {\n\t\t\tif (isStuck || samePositions) {\n\t\t\t\tconst newBlocksMap = blocksMap.slice();\n\t\t\t\tfor (let block of oldPositions) {\n\t\t\t\t\tnewBlocksMap[block.y][block.x] = figure.color;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tfigure: null,\n\t\t\t\t\tblocksMap: newBlocksMap\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tfigure: newFigure,\n\t\t\t\t\tblocksMap\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tfigure: isStuck ? figure : newFigure,\n\t\t\t\tblocksMap\n\t\t\t};\n\t\t}\n\t}\n\n\treturn setStateFn;\n}\n\nfunction getNextFigure(figure, action) {\n\tconst { x, y } = figure.position;\n\tswitch (action) {\n\t\tcase C.LEFT:\n\t\t\treturn figure.move({ x: x - 1, y });\n\t\tcase C.RIGHT:\n\t\t\treturn figure.move({ x: x + 1, y });\n\t\tcase C.DOWN:\n\t\t\treturn figure.move({ x, y: y + 1 });\n\t\tcase C.ROTATE:\n\t\t\treturn figure.rotate();\n\t\tdefault:\n\t\t\treturn figure;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}